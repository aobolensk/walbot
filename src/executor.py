import importlib
import inspect
import os
from collections import defaultdict
from typing import Any, Dict

from src import const
from src.api.command import (BaseCmd, Command, CommandBinding,
                             SupportedPlatforms)
from src.log import log


class Executor:
    def __init__(self) -> None:
        self.commands = {}
        self.binders: Dict[const.BotBackend, CommandBinding] = {}

    def register_command(self, cmd_name: str, command: Command) -> None:
        for binder in self.binders.values():
            binder.bind(cmd_name, command)

    def unregister_command(self, cmd_name: str) -> None:
        for binder in self.binders.values():
            binder.unbind(cmd_name)

    def load_commands(self) -> None:
        cmd_directory = os.path.join(os.getcwd(), "src", "cmd")
        cmd_modules = [
            "src.cmd." + os.path.splitext(path)[0] for path in os.listdir(cmd_directory)
            if os.path.isfile(os.path.join(cmd_directory, path)) and path.endswith(".py")]
        for module in cmd_modules:
            log.debug2(f"Processing commands from module: {module}")
            commands_file = importlib.import_module(module)
            commands = [
                obj[1] for obj in inspect.getmembers(commands_file, inspect.isclass)
                if (obj[1].__module__ == module) and issubclass(obj[1], BaseCmd)]
            if len(commands) == 1:
                commands = commands[0]
                if "bind" in [func[0] for func in inspect.getmembers(commands, inspect.isfunction)
                              if not func[0].startswith('_')]:
                    self.add_module(commands())
                else:
                    log.error(f"Class '{commands.__name__}' does not have bind() function")
            elif len(commands) > 1:
                log.error(f"Module '{module}' have more than 1 class in it")
            else:
                log.error(f"Module '{module}' have no classes in it")

    def add_module(self, module: BaseCmd) -> None:
        module.bind()

    def load_persistent_state(self, executor_config: Dict[str, Any]):
        for command in self.commands.values():
            if command.module_name is None:
                continue
            command.load_persistent_state(executor_config["commands_data"])
        for cmd_name, command in executor_config["custom_commands"].items():
            self.commands[cmd_name] = command

    def store_persistent_state(self, executor_config: Dict[str, Any]):
        for command in self.commands.values():
            if command.module_name is None:
                continue
            command.store_persistent_state(executor_config["commands_data"])
        executor_config["custom_commands"] = dict()
        for command in self.commands.values():
            if command.module_name is not None:
                continue
            executor_config["custom_commands"][command.command_name] = command

    def export_help(self, platform: SupportedPlatforms):
        modules = defaultdict(dict)
        for cmd_name, command in self.commands.items():
            if command.supported_platforms & platform:
                modules[command.module_name][cmd_name] = (command.description or "").strip()
        with open(os.path.join(
                "docs", f"{platform.name.title()}Commands.md"), "w", encoding="utf-8", newline='\n') as f:
            f.write("""<!-- WARNING! This file is automatically generated, do not change it manually -->
<!-- To regenerate this file launch `python walbot.py docs` command or simply launch the bot -->
\n""")
            f.write("# Table of Contents:\n")
            for module_name in sorted(modules.keys()):
                f.write(f"* [Module: {module_name}](#module-{module_name})\n")
            for module_name, module_commands in sorted(modules.items()):
                f.write(f"\n# Module: {module_name}\n")
                result = ""
                for cmd_name, cmd_help_text in sorted(module_commands.items()):
                    cmd_help_text = cmd_help_text.replace("<", "&lt;").replace(">", "&gt;").replace("\n", " \\\n")
                    result += f"\n**{cmd_name}**: {cmd_help_text}"
                    if self.commands[cmd_name].subcommand:
                        result += " \\\n    *This command can be used as subcommand*"
                    result += f" \\\n    *Default permission level: {self.commands[cmd_name].permission_level}*"
                    result += "\n"
                f.write(result)
